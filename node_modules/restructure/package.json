{
  "_args": [
    [
      {
        "raw": "restructure@^0.5.3",
        "scope": null,
        "escapedName": "restructure",
        "name": "restructure",
        "rawSpec": "^0.5.3",
        "spec": ">=0.5.3 <0.6.0",
        "type": "range"
      },
      "C:\\wamp64\\www\\ssc\\node_modules\\fontkit"
    ]
  ],
  "_from": "restructure@>=0.5.3 <0.6.0",
  "_id": "restructure@0.5.4",
  "_inCache": true,
  "_location": "/restructure",
  "_nodeVersion": "4.1.1",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/restructure-0.5.4.tgz_1493601675635_0.9421770751941949"
  },
  "_npmUser": {
    "name": "devongovett",
    "email": "devongovett@gmail.com"
  },
  "_npmVersion": "2.14.4",
  "_phantomChildren": {},
  "_requested": {
    "raw": "restructure@^0.5.3",
    "scope": null,
    "escapedName": "restructure",
    "name": "restructure",
    "rawSpec": "^0.5.3",
    "spec": ">=0.5.3 <0.6.0",
    "type": "range"
  },
  "_requiredBy": [
    "/fontkit"
  ],
  "_resolved": "https://registry.npmjs.org/restructure/-/restructure-0.5.4.tgz",
  "_shasum": "f54e7dd563590fb34fd6bf55876109aeccb28de8",
  "_shrinkwrap": null,
  "_spec": "restructure@^0.5.3",
  "_where": "C:\\wamp64\\www\\ssc\\node_modules\\fontkit",
  "author": {
    "name": "Devon Govett",
    "email": "devongovett@gmail.com"
  },
  "browserify": {
    "transform": [
      "browserify-optional"
    ]
  },
  "bugs": {
    "url": "https://github.com/devongovett/restructure/issues"
  },
  "dependencies": {
    "browserify-optional": "^1.0.0"
  },
  "description": "Declaratively encode and decode binary data",
  "devDependencies": {
    "chai": "~1.9.1",
    "coffee-coverage": "~0.4.2",
    "coffee-script": "~1.7.1",
    "concat-stream": "~1.4.5",
    "coveralls": "^2.10.0",
    "iconv-lite": "^0.4.7",
    "mocha": "~1.18.2",
    "mocha-lcov-reporter": "0.0.1"
  },
  "directories": {},
  "dist": {
    "shasum": "f54e7dd563590fb34fd6bf55876109aeccb28de8",
    "tarball": "https://registry.npmjs.org/restructure/-/restructure-0.5.4.tgz"
  },
  "gitHead": "2172bf0cf019fa7a4517cd9eddf1a23ae477df0b",
  "homepage": "https://github.com/devongovett/restructure",
  "keywords": [
    "binary",
    "struct",
    "encode",
    "decode"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "devongovett",
      "email": "devongovett@gmail.com"
    }
  ],
  "name": "restructure",
  "optionalDependencies": {},
  "readme": "# Restructure\n\n[![Build Status](https://travis-ci.org/devongovett/restructure.svg?branch=master)](https://travis-ci.org/devongovett/restructure)\n[![Coverage Status](https://coveralls.io/repos/devongovett/restructure/badge.png?branch=master)](https://coveralls.io/r/devongovett/restructure?branch=master)\n\nRestructure allows you to declaratively encode and decode binary data.\nIt supports a wide variety of types to enable you to express a multitude\nof binary formats without writing any parsing code.\n\nSome of the supported features are C-like structures, versioned structures,\npointers, arrays of any type, strings of a large number of encodings, enums,\nbitfields, and more.  See the documentation below for more details.\n\n## Example\n\nThis is just a small example of what Restructure can do. Check out the API documentation\nbelow for more information.\n\n```javascript\nvar r = require('restructure');\n\nvar Person = new r.Struct({\n  name: new r.String(r.uint8, 'utf8'),\n  age: r.uint8\n});\n\n// decode a person from a buffer\nvar stream = new r.DecodeStream(buffer);\nPerson.decode(stream); // returns an object with the fields defined above\n\n// encode a person from an object\n// pipe the stream to a destination, such as a file\nvar stream = new r.EncodeStream();\nstream.pipe(fs.createWriteStream('out.bin'));\n\nPerson.encode(stream, {\n  name: 'Devon',\n  age: 21\n});\n\nstream.end();\n```\n\n\n## API\n\nAll of the following types support three standard methods:\n\n* `decode(stream)` - decodes an instance of the type from the given DecodeStream\n* `size(value)` - returns the amount of space the value would take if encoded\n* `encode(stream, value)` - encodes the given value into the given EncodeStream\n\nRestructure supports a wide variety of types, but if you need to write your own for\nsome custom use that cannot be represented by them, you can do so by just implementing\nthe above methods. Then you can use your type just as you would any other type, in structures\nand whatnot.\n\n### Number Types\n\nThe following built-in number types are available:\n\n```javascript\nuint8, uint16, uint24, uint32, int8, int16, int24, int32, float, double, fixed16, fixed32\n```\n\nNumbers are big-endian (network order) by default, but little-endian is supported, too:\n\n```javascript\nuint16le, uint24le, uint32le, int16le, int24le, int32le, floatle, doublele, fixed16le, fixed32le\n```\n\nTo avoid ambiguity, big-endian may be used explicitly:\n\n```javascript\nuint16be, uint24be, uint32be, int16be, int24be, int32be, floatbe, doublebe, fixed16be, fixed32be\n```\n\n### Boolean\n\nBooleans are encoded as `0` or `1` using one of the above number types.\n\n```javascript\nvar bool = new r.Boolean(r.uint32);\n```\n\n### Reserved\n\nThe `Reserved` type simply skips data in a structure, where there are reserved fields.\nEncoding produces zeros.\n\n```javascript\n// 10 reserved uint8s (default is 1)\nvar reserved = new r.Reserved(r.uint8, 10);\n```\n\n### Optional\n\nThe `Optional` type only encodes or decodes when given condition is truthy.\n\n```javascript\n// includes field\nvar optional = new r.Optional(r.uint8, true);\n\n// excludes field\nvar optional = new r.Optional(r.uint8, false);\n\n// determine whether field is to be included at runtime with a function\nvar optional = new r.Optional(r.uint8, function() {\n  return this.flags & 0x50;\n});\n```\n\n### Enum\n\nThe `Enum` type maps a number to the value at that index in an array.\n\n```javascript\nvar color = new r.Enum(r.uint8, ['red', 'orange', 'yellow', 'green', 'blue', 'purple']);\n```\n\n### Bitfield\n\nThe `Bitfield` type maps a number to an object with boolean keys mapping to each bit in that number,\nas defined in an array.\n\n```javascript\nvar bitfield = new r.Bitfield(r.uint8, ['Jack', 'Kack', 'Lack', 'Mack', 'Nack', 'Oack', 'Pack', 'Quack']);\nbitfield.decode(stream);\n\nvar result = {\n  Jack: true,\n  Kack: false,\n  Lack: false,\n  Mack: true,\n  Nack: true,\n  Oack: false,\n  Pack: true,\n  Quack: true\n};\n\nbitfield.encode(stream, result);\n```\n\n### Buffer\n\nExtracts a slice of the buffer to a Node `Buffer`.  The length can be a constant, or taken from\na previous field in the parent structure.\n\n```javascript\n// fixed length\nvar buf = new r.Buffer(2);\n\n// length from parent structure\nvar struct = new r.Struct({\n  bufLen: r.uint8,\n  buf: new r.Buffer('bufLen')\n});\n```\n\n### String\n\nA `String` maps a JavaScript string to and from binary encodings.  The length can be a constant, taken\nfrom a previous field in the parent structure, or encoded using a number type immediately before the string.\n\nSupported encodings include `'ascii'`, `'utf8'`, `'ucs2'`, `'utf16le'`, `'utf16be'`, and if you also install\n[iconv-lite](https://github.com/ashtuchkin/iconv-lite), many other legacy codecs.\n\n```javascript\n// fixed length, ascii encoding by default\nvar str = new r.String(2);\n\n// length encoded as number before the string, utf8 encoding\nvar str = new r.String(r.uint8, 'utf8');\n\n// length from parent structure\nvar struct = new r.Struct({\n  len: r.uint8,\n  str: new r.String('len', 'utf16be')\n});\n\n// null-terminated string (also known as C string)\nvar str = new r.String(null, 'utf8')\n```\n\n### Array\n\nAn `Array` maps to and from a JavaScript array containing instances of a sub-type. The length can be a constant,\ntaken from a previous field in the parent structure, encoded using a number type immediately\nbefore the string, or computed by a function.\n\n```javascript\n// fixed length, containing numbers\nvar arr = new r.Array(r.uint16, 2);\n\n// length encoded as number before the array containing strings\nvar arr = new r.Array(new r.String(10), r.uint8);\n\n// length computed by a function\nvar arr = new r.Array(r.uint8, function() { return 5 });\n\n// length from parent structure\nvar struct = new r.Struct({\n  len: r.uint8,\n  arr: new r.Array(r.uint8, 'len')\n});\n\n// treat as amount of bytes instead (may be used in all the above scenarios)\nvar arr = new r.Array(r.uint16, 6, 'bytes');\n```\n\n### LazyArray\n\nThe `LazyArray` type extends from the `Array` type, and is useful for large arrays that you do not need to access sequentially. \nIt avoids decoding the entire array upfront, and instead only decodes and caches individual items as needed. It only works when \nthe elements inside the array have a fixed size.\n\nInstead of returning a JavaScript array, the `LazyArray` type returns a custom object that can be used to access the elements.\n\n```javascript\nvar arr = new r.LazyArray(r.uint16, 2048);\nvar res = arr.decode(stream);\n\n// get a single element\nvar el = res.get(2);\n\n// convert to a normal array (decode all elements)\nvar array = res.toArray();\n```\n\n### Struct\n\nA `Struct` maps to and from JavaScript objects, containing keys of various previously discussed types. Sub structures,\narrays of structures, and pointers to other types (discussed below) are supported.\n\n```javascript\nvar Person = new r.Struct({\n  name: new r.String(r.uint8, 'utf8'),\n  age: r.uint8\n});\n```\n\n### VersionedStruct\n\nA `VersionedStruct` is a `Struct` that has multiple versions. The version is typically encoded at\nthe beginning of the structure, or as a field in a parent structure. There is an optional `header`\ncommon to all versions, and separate fields listed for each version number.\n\n```javascript\n// the version is read as a uint8 in this example\n// you could also get the version from a key on the parent struct\nvar Person = new r.VersionedStruct(r.uint8, {\n  // optional header common to all versions\n  header: {\n    name: new r.String(r.uint8, 'utf8')\n  },\n  0: {\n    age: r.uint8\n  },\n  1: {\n    hairColor: r.Enum(r.uint8, ['black', 'brown', 'blonde'])\n  }\n});\n```\n\n### Pointer\n\nPointers map an address or offset encoded as a number, to a value encoded elsewhere in the buffer.\nThere are a few options you can use: `type`, `relativeTo`, `allowNull`, and `nullValue`. \nThe `type` option has these possible values:\n\n* `local` (default) - the encoded offset is relative to the start of the containing structure\n* `immediate` - the encoded offset is relative to the position of the pointer itself\n* `parent` - the encoded offset is relative to the parent structure of the immediate container\n* `global` - the encoded offset is global to the start of the file\n\nThe `relativeTo` option specifies that the encoded offset is relative to a field on the containing structure.\nBy default, pointers are relative to the start of the containing structure (`local`).\n\nThe `allowNull` option lets you specify whether zero offsets are allowed or should produce `null`. This is\nset to `true` by default. The `nullValue` option is related, and lets you override the encoded value that\nrepresents `null`. By default, the `nullValue` is zero.\n\nThe `lazy` option allows lazy decoding of the pointer's value by defining a getter on the parent object.\nThis only works when the pointer is contained within a Struct, but can be used to speed up decoding\nquite a bit when not all of the data is needed right away.\n\n```javascript\nvar Address = new r.Struct({\n  street: new r.String(r.uint8),\n  zip: new r.String(5)\n});\n\nvar Person = new r.Struct({\n  name: new r.String(r.uint8, 'utf8'),\n  age: r.uint8,\n  ptrStart: r.uint8,\n  address: new r.Pointer(r.uint8, Address)\n});\n```\n\nIf the type of a pointer is set to 'void', it is not decoded and the computed address in the buffer\nis simply returned. To encode a void pointer, create a `new r.VoidPointer(type, value)`.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/devongovett/restructure.git"
  },
  "scripts": {
    "cover": "mocha --require coverage.js --reporter html-cov > coverage.html",
    "coveralls": "mocha --require coverage.js --reporter mocha-lcov-reporter | coveralls",
    "postpublish": "rm -rf index.js src/*.js",
    "prepublish": "coffee -c src/ index.coffee",
    "test": "mocha"
  },
  "version": "0.5.4"
}

{
  "_args": [
    [
      {
        "raw": "natural",
        "scope": null,
        "escapedName": "natural",
        "name": "natural",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "C:\\wamp64\\www\\009"
    ]
  ],
  "_from": "natural@latest",
  "_id": "natural@0.5.4",
  "_inCache": true,
  "_location": "/natural",
  "_nodeVersion": "7.7.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/natural-0.5.4.tgz_1498138581415_0.0018157877493649721"
  },
  "_npmUser": {
    "email": "kkoch986@gmail.com",
    "name": "kkoch986"
  },
  "_npmVersion": "4.1.2",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "natural",
    "name": "natural",
    "raw": "natural",
    "rawSpec": "",
    "scope": null,
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/natural/-/natural-0.5.4.tgz",
  "_shasum": "ace41c1655daca2912dfbf99ad7b05314e205f54",
  "_shrinkwrap": null,
  "_spec": "natural",
  "_where": "C:\\wamp64\\www\\009",
  "author": {
    "email": "chris@chrisumbel.com",
    "name": "Chris Umbel"
  },
  "bugs": {
    "url": "https://github.com/NaturalNode/natural/issues"
  },
  "dependencies": {
    "apparatus": ">= 0.0.9",
    "sylvester": ">= 0.0.12",
    "underscore": ">=1.3.1",
    "webworker-threads": ">=0.6.2"
  },
  "description": "General natural language (tokenizing, stemming (English, Russian, Spanish), classification, inflection, phonetics, tfidf, WordNet, jaro-winkler, Levenshtein distance, Dice's Coefficient) facilities for node.",
  "devDependencies": {
    "jasmine-node": "~1.13.1",
    "proxyquire": "^1.8.0",
    "sinon": "^1.12.2",
    "uubench": "0.0.x"
  },
  "directories": {},
  "dist": {
    "shasum": "ace41c1655daca2912dfbf99ad7b05314e205f54",
    "tarball": "https://registry.npmjs.org/natural/-/natural-0.5.4.tgz"
  },
  "engines": {
    "node": ">=0.4.10"
  },
  "gitHead": "3b63344ae315513f6bc4aab35cc00718c6e1e282",
  "homepage": "https://github.com/NaturalNode/natural",
  "keywords": [
    "bayes",
    "classifier",
    "distance",
    "double",
    "doublemetaphone",
    "inflector",
    "jaro-winkler",
    "lancaster",
    "language",
    "levenshtein",
    "logistic",
    "metaphone",
    "natural",
    "phonetic",
    "porter",
    "regression",
    "stemmer",
    "tagger",
    "tf-idf",
    "wordnet"
  ],
  "license": "MIT",
  "main": "./lib/natural/index.js",
  "maintainers": [
    {
      "name": "Chris Umbel",
      "email": "chris@chrisumbel.com",
      "url": "http://www.chrisumbel.com"
    },
    {
      "name": "Rob Ellis",
      "email": "rob@silentrob.me"
    },
    {
      "name": "Ken Koch",
      "email": "kkoch986@gmail.com"
    }
  ],
  "name": "natural",
  "optionalDependencies": {
    "webworker-threads": ">=0.6.2"
  },
  "readme": "natural\n=======\n\n[![NPM version](https://img.shields.io/npm/v/natural.svg)](https://www.npmjs.com/package/natural)\n[![Build Status](https://travis-ci.org/NaturalNode/natural.png?branch=master)](https://travis-ci.org/NaturalNode/natural)\n\n\"Natural\" is a general natural language facility for nodejs. Tokenizing,\nstemming, classification, phonetics, tf-idf, WordNet, string similarity,\nand some inflections are currently supported.\n\nIt's still in the early stages, so we're very interested in bug reports,\ncontributions and the like.\n\nNote that many algorithms from Rob Ellis's [node-nltools](https://github.com/NaturalNode/node-nltools) are\nbeing merged into this project and will be maintained from here onward.\n\nAt the moment, most of the algorithms are English-specific, but in the long-term, some diversity\nwill be in order. Thanks to Polyakov Vladimir, Russian stemming has been added!, Thanks to David Przybilla, Spanish stemming has been added!.\n\nAside from this README, the only documentation is [this DZone article](http://www.dzone.com/links/r/using_natural_a_nlp_module_for_nodejs.html), [this free course on Egghead.io](https://egghead.io/courses/natural-language-processing-in-javascript-with-natural), and [here on my blog](http://www.chrisumbel.com/article/node_js_natural_language_porter_stemmer_lancaster_bayes_naive_metaphone_soundex), which is a bit older.\n\n### TABLE OF CONTENTS\n\n* [Installation](#installation)\n* [Tokenizers](#tokenizers)\n* [String Distance](#string-distance)\n* [Stemmers](#stemmers)\n* [Classifiers](#classifiers)\n* [Phonetics](#phonetics)\n* [Inflectors](#inflectors)\n* [N-Grams](#n-grams)\n* [tf-idf](#tf-idf)\n* [Tries](#tries)\n* [EdgeWeightedDigraph](#edgeweighteddigraph)\n* [ShortestPathTree](#shortestpathtree)\n* [LongestPathTree](#longestpathtree)\n* [WordNet](#wordnet)\n* [Spellcheck](#spellcheck)\n* [POS Tagger](#pos-tagger)\n* [Acknowledgements/references](#acknowledgements-and-references)\n* [Development](#development)\n* [License](#license)\n\n\n## Installation\n\nIf you're just looking to use natural without your own node application,\nyou can install via NPM like so:\n\n    npm install natural\n\nIf you're interested in contributing to natural, or just hacking on it, then by all\nmeans fork away!\n\n## Tokenizers\n\nWord, Regexp, and [Treebank tokenizers](http://www.cis.upenn.edu/~treebank/tokenization.html) are provided for breaking text up into\narrays of tokens:\n\n```javascript\nvar natural = require('natural');\nvar tokenizer = new natural.WordTokenizer();\nconsole.log(tokenizer.tokenize(\"your dog has fleas.\"));\n// [ 'your', 'dog', 'has', 'fleas' ]\n```\n\nThe other tokenizers follow a similar pattern:\n\n```javascript\ntokenizer = new natural.TreebankWordTokenizer();\nconsole.log(tokenizer.tokenize(\"my dog hasn't any fleas.\"));\n// [ 'my', 'dog', 'has', 'n\\'t', 'any', 'fleas', '.' ]\n\ntokenizer = new natural.RegexpTokenizer({pattern: /\\-/});\nconsole.log(tokenizer.tokenize(\"flea-dog\"));\n// [ 'flea', 'dog' ]\n\ntokenizer = new natural.WordPunctTokenizer();\nconsole.log(tokenizer.tokenize(\"my dog hasn't any fleas.\"));\n// [ 'my',  'dog',  'hasn',  '\\'',  't',  'any',  'fleas',  '.' ]\n```\n\n## String Distance\n\nNatural provides an implementation of the [Jaro–Winkler](http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance) string distance measuring algorithm.\nThis will return a number between 0 and 1 which tells how closely the strings match (0 = not at all, 1 = exact match):\n\n```javascript\nvar natural = require('natural');\nconsole.log(natural.JaroWinklerDistance(\"dixon\",\"dicksonx\"))\nconsole.log(natural.JaroWinklerDistance('not', 'same'));\n```\n\nOutput:\n\n```javascript\n0.7466666666666666\n0\n```\n\nNatural also offers support for Levenshtein distances:\n\n```javascript\nvar natural = require('natural');\nconsole.log(natural.LevenshteinDistance(\"ones\",\"onez\"));\nconsole.log(natural.LevenshteinDistance('one', 'one'));\n```\n\nOutput:\n\n```javascript\n1\n0\n```\n\nThe cost of the three edit operations are modifiable for Levenshtein:\n\n```javascript\nconsole.log(natural.LevenshteinDistance(\"ones\",\"onez\", {\n    insertion_cost: 1,\n    deletion_cost: 1,\n    substitution_cost: 1\n}));\n```\n\nOutput:\n\n```javascript\n1\n```\n\nAnd Dice's co-efficient:\n\n```javascript\nvar natural = require('natural');\nconsole.log(natural.DiceCoefficient('thing', 'thing'));\nconsole.log(natural.DiceCoefficient('not', 'same'));\n```\n\nOutput:\n\n```javascript\n1\n0\n```\n\n## Stemmers\n\nCurrently stemming is supported via the [Porter](http://tartarus.org/martin/PorterStemmer/index.html) and [Lancaster](http://www.comp.lancs.ac.uk/computing/research/stemming/) (Paice/Husk) algorithms.\n\n```javascript\nvar natural = require('natural');\n```\n\nThis example uses a Porter stemmer. \"word\" is returned.\n\n```javascript\nconsole.log(natural.PorterStemmer.stem(\"words\")); // stem a single word\n```\n\n in Russian:\n\n```javascript\nconsole.log(natural.PorterStemmerRu.stem(\"падший\"));\n```\n\n in Spanish:\n\n```javascript\nconsole.log(natural.PorterStemmerEs.stem(\"jugaría\"));\n```\n\n`attach()` patches `stem()` and `tokenizeAndStem()` to String as a shortcut to\n`PorterStemmer.stem(token)`. `tokenizeAndStem()` breaks text up into single words\nand returns an array of stemmed tokens.\n\n```javascript\nnatural.PorterStemmer.attach();\nconsole.log(\"i am waking up to the sounds of chainsaws\".tokenizeAndStem());\nconsole.log(\"chainsaws\".stem());\n```\n\nthe same thing can be done with a Lancaster stemmer:\n\n```javascript\nnatural.LancasterStemmer.attach();\nconsole.log(\"i am waking up to the sounds of chainsaws\".tokenizeAndStem());\nconsole.log(\"chainsaws\".stem());\n```\n\n## Classifiers\n\nTwo classifiers are currently supported, [Naive Bayes](http://en.wikipedia.org/wiki/Naive_Bayes_classifier) and [logistic regression](http://en.wikipedia.org/wiki/Logistic_regression).\nThe following examples use the BayesClassifier class, but the\nLogisticRegressionClassifier class could be substituted instead.\n\n```javascript\nvar natural = require('natural');\nvar classifier = new natural.BayesClassifier();\n```\n\nYou can train the classifier on sample text. It will use reasonable defaults to\ntokenize and stem the text.\n\n```javascript\nclassifier.addDocument('i am long qqqq', 'buy');\nclassifier.addDocument('buy the q\\'s', 'buy');\nclassifier.addDocument('short gold', 'sell');\nclassifier.addDocument('sell gold', 'sell');\n\nclassifier.train();\n```\n\nOutputs \"sell\"\n\n```javascript\nconsole.log(classifier.classify('i am short silver'));\n```\n\nOutputs \"buy\"\n\n```javascript\nconsole.log(classifier.classify('i am long copper'));\n```\n\nYou have access to the set of matched classes and the associated value from the classifier.\n\nOutputs:\n\n```javascript\n[ { label: 'buy', value: 0.39999999999999997 },\n  { label: 'sell', value: 0.19999999999999998 } ]\n```\n\nFrom this:\n\n```javascript\nconsole.log(classifier.getClassifications('i am long copper'));\n```\n\nThe classifier can also be trained with and can classify arrays of tokens, strings, or\nany mixture of the two. Arrays let you use entirely custom data with your own\ntokenization/stemming, if you choose to implement it.\n\n```javascript\nclassifier.addDocument(['sell', 'gold'], 'sell');\n```\n\nThe training process can be monitored by subscribing to the event `trainedWithDocument` that's emitted by the classifier, this event's emitted each time a document is finished being trained against:\n\n    classifier.events.on('trainedWithDocument', function (obj) {\n       console.log(obj);\n       /* {\n       *   total: 23 // There are 23 total documents being trained against\n       *   index: 12 // The index/number of the document that's just been trained against\n       *   doc: {...} // The document that has just been indexed\n       *  }\n       */\n    });\n\nA classifier can also be persisted and recalled so you can reuse a training\n\n```javascript\nclassifier.save('classifier.json', function(err, classifier) {\n    // the classifier is saved to the classifier.json file!\n});\n```\n\nTo recall from the classifier.json saved above:\n\n```javascript\nnatural.BayesClassifier.load('classifier.json', null, function(err, classifier) {\n    console.log(classifier.classify('long SUNW'));\n    console.log(classifier.classify('short SUNW'));\n});\n```\n\nA classifier can also be serialized and deserialized like so:\n\n```javascript\nvar classifier = new natural.BayesClassifier();\nclassifier.addDocument(['sell', 'gold'], 'sell');\nclassifier.addDocument(['buy', 'silver'], 'buy');\n\n// serialize\nvar raw = JSON.stringify(classifier);\n// deserialize\nvar restoredClassifier = natural.BayesClassifier.restore(JSON.parse(raw));\nconsole.log(restoredClassifier.classify('i should sell that'));\n```\n\n__Note:__ if using the classifier for languages other than English you may need\nto pass in the stemmer to use. In fact, you can do this for any stemmer including\nalternate English stemmers. The default is the `PorterStemmer`.\n\n```javascript\nconst PorterStemmerRu = require('./node_modules/natural/lib/natural/stemmers/porter_stemmer_ru');\nvar classifier = new natural.BayesClassifier(PorterStemmerRu);\n```\n\n## Phonetics\n\nPhonetic matching (sounds-like) matching can be done with the [SoundEx](http://en.wikipedia.org/wiki/Soundex),\n[Metaphone](http://en.wikipedia.org/wiki/Metaphone) or [DoubleMetaphone](http://en.wikipedia.org/wiki/Metaphone#Double_Metaphone) algorithms\n\n```javascript\nvar natural = require('natural');\nvar metaphone = natural.Metaphone;\nvar soundEx = natural.SoundEx;\n\nvar wordA = 'phonetics';\nvar wordB = 'fonetix';\n```\n\nTo test the two words to see if they sound alike:\n\n```javascript\nif(metaphone.compare(wordA, wordB))\n    console.log('they sound alike!');\n```\n\nThe raw phonetics are obtained with `process()`:\n\n```javascript\nconsole.log(metaphone.process('phonetics'));\n```\n\nA maximum code length can be supplied:\n\n```javascript\nconsole.log(metaphone.process('phonetics', 3));\n```\n\n`DoubleMetaphone` deals with two encodings returned in an array. This\nfeature is experimental and subject to change:\n\n```javascript\nvar natural = require('natural');\nvar dm = natural.DoubleMetaphone;\n\nvar encodings = dm.process('Matrix');\nconsole.log(encodings[0]);\nconsole.log(encodings[1]);\n```\n\nAttaching will patch String with useful methods:\n\n```javascript\nmetaphone.attach();\n```\n\n`soundsLike` is essentially a shortcut to `Metaphone.compare`:\n\n```javascript\nif(wordA.soundsLike(wordB))\n    console.log('they sound alike!');\n```\n\nThe raw phonetics are obtained with `phonetics()`:\n\n```javascript\nconsole.log('phonetics'.phonetics());\n```\n\nFull text strings can be tokenized into arrays of phonetics (much like how tokenization-to-arrays works for stemmers):\n\n```javascript\nconsole.log('phonetics rock'.tokenizeAndPhoneticize());\n```\n\nSame module operations applied with `SoundEx`:\n\n```javascript\nif(soundEx.compare(wordA, wordB))\n    console.log('they sound alike!');\n```\n\nThe same String patches apply with `soundEx`:\n\n```javascript\nsoundEx.attach();\n\nif(wordA.soundsLike(wordB))\n    console.log('they sound alike!');\n\nconsole.log('phonetics'.phonetics());\n```\n\n## Inflectors\n\n### Nouns\n\nNouns can be pluralized/singularized with a `NounInflector`:\n\n```javascript\nvar natural = require('natural');\nvar nounInflector = new natural.NounInflector();\n```\n\nTo pluralize a word (outputs \"radii\"):\n\n```javascript\nconsole.log(nounInflector.pluralize('radius'));\n```\n\nTo singularize a word (outputs \"beer\"):\n\n```javascript\nconsole.log(nounInflector.singularize('beers'));\n```\n\nLike many of the other features, String can be patched to perform the operations\ndirectly. The \"Noun\" suffix on the methods is necessary, as verbs will be\nsupported in the future.\n\n```javascript\nnounInflector.attach();\nconsole.log('radius'.pluralizeNoun());\nconsole.log('beers'.singularizeNoun());\n```\n\n### Numbers\n\nNumbers can be counted with a CountInflector:\n\n```javascript\nvar countInflector = natural.CountInflector;\n```\n\nOutputs \"1st\":\n\n```javascript\nconsole.log(countInflector.nth(1));\n```\n\nOutputs \"111th\":\n\n```javascript\nconsole.log(countInflector.nth(111));\n```\n\n### Present Tense Verbs\n\nPresent Tense Verbs can be pluralized/singularized with a PresentVerbInflector.\nThis feature is still experimental as of 0.0.42, so use with caution, and please\nprovide feedback.\n\n```javascript\nvar verbInflector = new natural.PresentVerbInflector();\n```\n\nOutputs \"becomes\":\n\n```javascript\nconsole.log(verbInflector.singularize('become'));\n```\n\nOutputs \"become\":\n\n```javascript\nconsole.log(verbInflector.pluralize('becomes'));\n```\n\nLike many other natural modules, `attach()` can be used to patch strings with\nhandy methods.\n\n```javascript\nverbInflector.attach();\nconsole.log('walk'.singularizePresentVerb());\nconsole.log('walks'.pluralizePresentVerb());\n```\n\n\n## N-Grams\n\nn-grams can be obtained for either arrays or strings (which will be tokenized\nfor you):\n\n```javascript\nvar NGrams = natural.NGrams;\n```\n\n### bigrams\n\n```javascript\nconsole.log(NGrams.bigrams('some words here'));\nconsole.log(NGrams.bigrams(['some',  'words',  'here']));\n```\n\nBoth of the above output: `[ [ 'some', 'words' ], [ 'words', 'here' ] ]`\n\n### trigrams\n\n```javascript\nconsole.log(NGrams.trigrams('some other words here'));\nconsole.log(NGrams.trigrams(['some',  'other', 'words',  'here']));\n```\n\nBoth of the above output: `[ [ 'some', 'other', 'words' ],\n  [ 'other', 'words', 'here' ] ]`\n\n### arbitrary n-grams\n\n```javascript\nconsole.log(NGrams.ngrams('some other words here for you', 4));\nconsole.log(NGrams.ngrams(['some', 'other', 'words', 'here', 'for',\n    'you'], 4));\n```\n\nThe above outputs: `[ [ 'some', 'other', 'words', 'here' ],\n  [ 'other', 'words', 'here', 'for' ],\n  [ 'words', 'here', 'for', 'you' ] ]`\n\n### padding\n\nn-grams can also be returned with left or right padding by passing a start and/or end symbol to the bigrams, trigrams or ngrams.\n\n```javascript\nconsole.log(NGrams.ngrams('some other words here for you', 4, '[start]', '[end]'));\n```\n\nThe above will output:\n```\n[ [ '[start]', '[start]', '[start]', 'some' ],\n  [ '[start]', '[start]', 'some', 'other' ],\n  [ '[start]', 'some', 'other', 'words' ],\n  [ 'some', 'other', 'words', 'here' ],\n  [ 'other', 'words', 'here', 'for' ],\n  [ 'words', 'here', 'for', 'you' ],\n  [ 'here', 'for', 'you', '[end]' ],\n  [ 'for', 'you', '[end]', '[end]' ],\n  [ 'you', '[end]', '[end]', '[end]' ] ]\n```\n\nFor only end symbols, pass `null` for the start symbol, for instance:\n```javascript\nconsole.log(NGrams.ngrams('some other words here for you', 4, null, '[end]'));\n```\n\nWill output:\n```\n[ [ 'some', 'other', 'words', 'here' ],\n  [ 'other', 'words', 'here', 'for' ],\n  [ 'words', 'here', 'for', 'you' ],\n  [ 'here', 'for', 'you', '[end]' ],\n  [ 'for', 'you', '[end]', '[end]' ],\n  [ 'you', '[end]', '[end]', '[end]' ] ]\n```\n\n### NGramsZH\n\nFor Chinese like languages, you can use NGramsZH to do a n-gram, and all apis are the same:\n\n```javascript\nvar NGramsZH = natural.NGramsZH;\nconsole.log(NGramsZH.bigrams('中文测试'));\nconsole.log(NGramsZH.bigrams(['中',  '文',  '测', '试']));\nconsole.log(NGramsZH.trigrams('中文测试'));\nconsole.log(NGramsZH.trigrams(['中',  '文', '测',  '试']));\nconsole.log(NGramsZH.ngrams('一个中文测试', 4));\nconsole.log(NGramsZH.ngrams(['一', '个', '中', '文', '测',\n    '试'], 4));\n```\n\n## tf-idf\n\n[Term Frequency–Inverse Document Frequency (tf-idf)](http://en.wikipedia.org/wiki/Tf%E2%80%93idf) is implemented to determine how important a word (or words) is to a\ndocument relative to a corpus. The following example will add four documents to\na corpus and determine the weight of the word \"node\" and then the weight of the\nword \"ruby\" in each document.\n\n```javascript\nvar natural = require('natural');\nvar TfIdf = natural.TfIdf;\nvar tfidf = new TfIdf();\n\ntfidf.addDocument('this document is about node.');\ntfidf.addDocument('this document is about ruby.');\ntfidf.addDocument('this document is about ruby and node.');\ntfidf.addDocument('this document is about node. it has node examples');\n\nconsole.log('node --------------------------------');\ntfidf.tfidfs('node', function(i, measure) {\n    console.log('document #' + i + ' is ' + measure);\n});\n\nconsole.log('ruby --------------------------------');\ntfidf.tfidfs('ruby', function(i, measure) {\n    console.log('document #' + i + ' is ' + measure);\n});\n```\n\nThe above outputs:\n\n```\nnode --------------------------------\ndocument #0 is 1\ndocument #1 is 0\ndocument #2 is 1\ndocument #3 is 2\nruby --------------------------------\ndocument #0 is 0\ndocument #1 is 1.2876820724517808\ndocument #2 is 1.2876820724517808\ndocument #3 is 0\n```\n\nThis approach can also be applied to individual documents.\n\nThe following example measures the term \"node\" in the first and second documents.\n\n```javascript\nconsole.log(tfidf.tfidf('node', 0));\nconsole.log(tfidf.tfidf('node', 1));\n```\n\nA TfIdf instance can also load documents from files on disk.\n\n```javascript\nvar tfidf = new TfIdf();\ntfidf.addFileSync('data_files/one.txt');\ntfidf.addFileSync('data_files/two.txt');\n```\n\nMultiple terms can be measured as well, with their weights being added into\na single measure value. The following example determines that the last document\nis the most relevant to the words \"node\" and \"ruby\".\n\n```javascript\nvar natural = require('natural');\nvar TfIdf = natural.TfIdf;\nvar tfidf = new TfIdf();\n\ntfidf.addDocument('this document is about node.');\ntfidf.addDocument('this document is about ruby.');\ntfidf.addDocument('this document is about ruby and node.');\n\ntfidf.tfidfs('node ruby', function(i, measure) {\n    console.log('document #' + i + ' is ' + measure);\n});\n```\n\nThe above outputs:\n\n```\ndocument #0 is 1\ndocument #1 is 1\ndocument #2 is 2\n```\n\nThe examples above all use strings, which case natural to automatically tokenize the input.\nIf you wish to perform your own tokenization or other kinds of processing, you\ncan do so, then pass in the resultant arrays later. This approach allows you to bypass natural's\ndefault preprocessing.\n\n```javascript\nvar natural = require('natural');\nvar TfIdf = natural.TfIdf;\nvar tfidf = new TfIdf();\n\ntfidf.addDocument(['document', 'about', 'node']);\ntfidf.addDocument(['document', 'about', 'ruby']);\ntfidf.addDocument(['document', 'about', 'ruby', 'node']);\ntfidf.addDocument(['document', 'about', 'node', 'node', 'examples']);\n\ntfidf.tfidfs(['node', 'ruby'], function(i, measure) {\n    console.log('document #' + i + ' is ' + measure);\n});\n```\n\nIt's possible to retrieve a list of all terms in a document, sorted by their\nimportance.\n\n```javascript\ntfidf.listTerms(0 /*document index*/).forEach(function(item) {\n    console.log(item.term + ': ' + item.tfidf);\n});\n```\n\nA TfIdf instance can also be serialized and deserialized for save and recall.\n\n```javascript\nvar tfidf = new TfIdf();\ntfidf.addDocument('document one', 'un');\ntfidf.addDocument('document Two', 'deux');\nvar s = JSON.stringify(tfidf);\n// save \"s\" to disk, database or otherwise\n\n// assuming you pulled \"s\" back out of storage.\nvar tfidf = new TfIdf(JSON.parse(s));\n```\n\n## Tries\n\nTries are a very efficient data structure used for prefix-based searches.\nNatural comes packaged with a basic Trie implementation which can support match collection along a path,\nexistence search and prefix search.\n\n### Building The Trie\n\nYou need to add words to build up the dictionary of the Trie, this is an example of basic Trie set up:\n\n```javascript\nvar natural = require('natural');\nvar Trie = natural.Trie;\n\nvar trie = new Trie();\n\n// Add one string at a time\ntrie.addString(\"test\");\n\n// Or add many strings\ntrie.addStrings([\"string1\", \"string2\", \"string3\"]);\n```\n\n### Searching\n\n#### Contains\n\nThe most basic operation on a Trie is to see if a search string is marked as a word in the Trie.\n\n```javascript\nconsole.log(trie.contains(\"test\")); // true\nconsole.log(trie.contains(\"asdf\")); // false\n```\n\n### Find Prefix\n\nThe find prefix search will find the longest prefix that is identified as a word in the trie.\nIt will also return the remaining portion of the string which it was not able to match.\n\n```javascript\nconsole.log(trie.findPrefix(\"tester\"));     // ['test', 'er']\nconsole.log(trie.findPrefix(\"string4\"));    // [null, '4']\nconsole.log(trie.findPrefix(\"string3\"));    // ['string3', '']\n```\n\n### All Prefixes on Path\n\nThis search will return all prefix matches along the search string path.\n\n```javascript\ntrie.addString(\"tes\");\ntrie.addString(\"est\");\nconsole.log(trie.findMatchesOnPath(\"tester\")); // ['tes', 'test'];\n```\n\n### All Keys with Prefix\n\nThis search will return all of the words in the Trie with the given prefix, or [ ] if not found.\n\n```javascript\nconsole.log(trie.keysWithPrefix(\"string\")); // [\"string1\", \"string2\", \"string3\"]\n```\n\n### Case-Sensitivity\n\nBy default the trie is case-sensitive, you can use it in case-_in_sensitive mode by passing `false`\nto the Trie constructor.\n\n```javascript\ntrie.contains(\"TEST\"); // false\n\nvar ciTrie = new Trie(false);\nciTrie.addString(\"test\");\nciTrie.contains(\"TEsT\"); // true\n```\nIn the case of the searches which return strings, all strings returned will be in lower case if you are in case-_in_sensitive mode.\n\n## EdgeWeightedDigraph\n\nEdgeWeightedDigraph represents a digraph, you can add an edge, get the number vertexes, edges, get all edges and use toString to print the Digraph.\n\ninitialize a digraph:\n\n```javascript\nvar EdgeWeightedDigraph = natural.EdgeWeightedDigraph;\nvar digraph = new EdgeWeightedDigraph();\ndigraph.add(5,4,0.35);\ndigraph.add(5,1,0.32);\ndigraph.add(1,3,0.29);\ndigraph.add(6,2,0.40);\ndigraph.add(3,6,0.52);\ndigraph.add(6,4,0.93);\n```\nthe api used is: add(from, to, weight).\n\nget the number of vertexes:\n\n```javascript\nconsole.log(digraph.v());\n```\nyou will get 5.\n\nget the number of edges:\n\n```javascript\nconsole.log(digraph.e());\n```\nyou will get 5.\n\n\n\n## ShortestPathTree\n\nShortestPathTree represents a data type for solving the single-source shortest paths problem in\nedge-weighted directed acyclic graphs (DAGs).\nThe edge weights can be positive, negative, or zero. There are three APIs:\ngetDistTo(vertex),\nhasPathTo(vertex),\npathTo(vertex).\n\n```javascript\nvar ShortestPathTree = natural.ShortestPathTree;\nvar spt = new ShortestPathTree(digraph, 5);\n```\ndigraph is an instance of EdgeWeightedDigraph, the second param is the start vertex of DAG.\n\n### getDistTo(vertex)\n\nWill return the dist to vertex.\n\n```javascript\nconsole.log(spt.getDistTo(4));\n```\nthe output will be: 0.35\n\n### hasDistTo(vertex)\n\n```javascript\nconsole.log(spt.hasDistTo(4));\nconsole.log(spt.hasDistTo(5));\n```\n\noutput will be:\n\n```javascript\ntrue\nfalse\n```\n\n### pathTo(vertex)\nthis will return a shortest path:\n\n```javascript\nconsole.log(spt.pathTo(4));\n```\n\noutput will be:\n\n```javascript\n[5, 4]\n```\n\n## LongestPathTree\n\nLongestPathTree represents a data type for solving the single-source longest paths problem in\nedge-weighted directed acyclic graphs (DAGs).\nThe edge weights can be positive, negative, or zero. There are three APIs same as ShortestPathTree:\ngetDistTo(vertex),\nhasPathTo(vertex),\npathTo(vertex).\n\n```javascript\nvar ShortestPathTree = natural.ShortestPathTree;\nvar spt = new ShortestPathTree(digraph, 5);\n```\ndigraph is an instance of EdgeWeightedDigraph, the second param is the start vertex of DAG.\n\n### getDistTo(vertex)\n\nWill return the dist to vertex.\n\n```javascript\nconsole.log(spt.getDistTo(4));\n```\nthe output will be: 2.06\n\n### hasDistTo(vertex)\n\n```javascript\nconsole.log(spt.hasDistTo(4));\nconsole.log(spt.hasDistTo(5));\n```\n\noutput will be:\n\n```javascript\ntrue\nfalse\n```\n\n### pathTo(vertex)\nthis will return a longest path:\n\n```javascript\nconsole.log(spt.pathTo(4));\n```\n\noutput will be:\n\n```javascript\n[5, 1, 3, 6, 4]\n```\n\n## WordNet\n\nOne of the newest and most experimental features in natural is WordNet integration. Here's an\nexample of using natural to look up definitions of the word node. To use the WordNet module,\nfirst install the WordNet database files using [wordnet-db](https://github.com/moos/wordnet-db):\n\n    npm install wordnet-db\n\nKeep in mind that the WordNet integration is to be considered experimental at this point,\nand not production-ready. The API is also subject to change.  For an implementation with vastly increased performance, as well as a command-line interface, see [wordpos](https://github.com/moos/wordpos).\n\nHere's an example of looking up definitions for the word \"node\".\n\n```javascript\nvar wordnet = new natural.WordNet();\n\nwordnet.lookup('node', function(results) {\n    results.forEach(function(result) {\n        console.log('------------------------------------');\n        console.log(result.synsetOffset);\n        console.log(result.pos);\n        console.log(result.lemma);\n        console.log(result.synonyms);\n        console.log(result.pos);\n        console.log(result.gloss);\n    });\n});\n```\n\nGiven a synset offset and a part of speech, a definition can be looked up directly.\n\n```javascript\nvar wordnet = new natural.WordNet();\n\nwordnet.get(4424418, 'n', function(result) {\n    console.log('------------------------------------');\n    console.log(result.lemma);\n    console.log(result.pos);\n    console.log(result.gloss);\n    console.log(result.synonyms);\n});\n```\n\nIf you have _manually_ downloaded the WordNet database files, you can pass the folder to the constructor:\n\n```javascript\nvar wordnet = new natural.WordNet('/my/wordnet/dict');\n```\n\nAs of v0.1.11, WordNet data files are no longer automatically downloaded.\n\nPrinceton University \"About WordNet.\" WordNet. Princeton University. 2010. <http://wordnet.princeton.edu>\n\n## Spellcheck\n\nA probabilistic spellchecker based on http://norvig.com/spell-correct.html\n\nThis is best constructed with an array of tokens from a corpus, but a simple list of words from a dictionary will work.\n\n```javascript\nvar corpus = ['something', 'soothing'];\nvar spellcheck = new natural.Spellcheck(corpus);\n```\n\nIt uses the trie datastructure for fast boolean lookup of a word\n\n```javascript\nspellcheck.isCorrect('cat'); // false\n```\n\nIt suggests corrections (sorted by probability in descending order) that are up to a maximum edit distance away from the input word. According to Norvig, a max distance of 1 will cover 80% to 95% of spelling mistakes. After a distance of 2, it becomes very slow.\n\n```javascript\nspellcheck.getCorrections('soemthing', 1); // ['something']\nspellcheck.getCorrections('soemthing', 2); // ['something', 'soothing']\n```\n\n## POS Tagger\n\nThis is a part-of-speech tagger based on Eric Brill's transformational\nalgorithm. Transformation rules are specified in external files.\n\n### Usage\n```javascript\nvar natural = require(\"natural\");\nvar path = require(\"path\");\n\nvar base_folder = path.join(path.dirname(require.resolve(\"natural\")), \"brill_pos_tagger\");\nvar rulesFilename = base_folder + \"/data/English/tr_from_posjs.txt\";\nvar lexiconFilename = base_folder + \"/data/English/lexicon_from_posjs.json\";\nvar defaultCategory = 'N';\n\nvar lexicon = new natural.Lexicon(lexiconFilename, defaultCategory);\nvar rules = new natural.RuleSet(rulesFilename);\nvar tagger = new natural.BrillPOSTagger(lexicon, rules);\n\nvar sentence = [\"I\", \"see\", \"the\", \"man\", \"with\", \"the\", \"telescope\"];\nconsole.log(JSON.stringify(tagger.tag(sentence)));\n// [[\"I\",\"NN\"],[\"see\",\"VB\"],[\"the\",\"DT\"],[\"man\",\"NN\"],[\"with\",\"IN\"],[\"the\",\"DT\"],[\"telescope\",\"NN\"]]\n\n```\n\n### Lexicon\nThe lexicon is either a JSON file that has the following structure:\n```javascript\n{\n  \"word1\": [\"cat1\"],\n  \"word2\": [\"cat2\", \"cat3\"],\n  ...\n}\n```\nor a text file:\n```\nword1 cat1 cat2\nword2 cat3\n...\n```\nWords may have multiple categories in the lexicon file. The tagger uses only\nthe first category specified.\n\n### Specifying transformation rules\nTransformation rules are specified as follows:\n```\nOLD_CAT NEW_CAT PREDICATE PARAMETER\n```\nThis means that if the category of the current position is OLD_CAT and the predicate is true, the category is replaced by NEW_CAT. The predicate\nmay use the parameter in different ways: sometimes the parameter is used for\nspecifying the outcome of the predicate:\n```\nNN CD CURRENT-WORD-IS-NUMBER YES\n```\nThis means that if the outcome of predicate CURRENT-WORD-IS-NUMBER is YES, the\ncategory is replaced by <code>CD</code>.\nThe parameter can also be used to check the category of a word in the sentence:\n```\nVBD NN PREV-TAG DT\n```\nHere the category of the previous word must be <code>DT</code> for the rule to be applied.\n\n### Algorithm\nThe tagger applies transformation rules that may change the category of words. The input sentence must be split into words which are assigned with categories. The tagged sentence is then processed from left to right. At each step all rules are applied once; rules are applied in the order in which they are specified. Algorithm:\n```javascript\nfunction(sentence) {\n  var tagged_sentence = new Array(sentence.length);\n\n  // snip\n\n  // Apply transformation rules\n  for (var i = 0, size = sentence.length; i < size; i++) {\n    this.transformation_rules.forEach(function(rule) {\n      rule.apply(tagged_sentence, i);\n    });\n  }\n  return(tagged_sentence);\n}\n```\n\n### Adding a predicate\nPredicates are defined in module <code>lib/RuleTemplates.js</code>. In that file\npredicate names are mapped to metadata for generaring transformation rules. The following properties must be supplied:\n* Name of the predicate\n* A function that evaluates the predicate (should return a boolean)\n* A window <code>[i, j]</code> that defines the span of the predicate in the \nsentence relative to the current position\n* The number of parameter the predicate needs: 0, 1 or 2\n* If relevant, a function for parameter 1 that returns its possible values \nat the current position in the sentence (for generating rules in training)\n* If relevant, a function for parameter 2 that returns its possible values \nat the current position in the sentence (for training)\n\nA typical entry for a rule templates looks like this:\n```javascript\n\"NEXT-TAG\": {\n    // maps to the predicate function\n    \"function\": next_tag_is,\n    // Minimum required window before or after current position to be a relevant predicate\n    \"window\": [0, 1],\n    // The number of parameters the predicate takes\n    \"nrParameters\": 1,\n    // Function that returns relevant values for parameter 1\n    \"parameter1Values\": nextTagParameterValues\n  }\n```\nA predicate function accepts a tagged sentence, the current position in the \nsentence that should be tagged, and the outcome(s) of the predicate. \nAn example of a predicate that checks the category of the current word:\n```javascript\nfunction next_tag_is(tagged_sentence, i, parameter) {\n  if (i < tagged_sentence.length - 1) {\n    return(tagged_sentence[i+1][1] === parameter);\n  }\n  else {\n    return(false);\n  }\n}\n```\n\nA values function for a parameter returns an array all possible parameter \nvalues given a location in a tagged sentence.\n```javascript\nfunction nextTagParameterValues(sentence, i) {\n  if (i < sentence.length - 1) {\n    return [sentence[i + 1].tag];\n  }\n  else {\n    return [];\n  }\n}\n```\nPlease note that these functions work with a different data type. Here, a \nsentence is an array of tokens and tokens are maps that have at least a \ntoken (word) and a tag. \n\n\n### Training\nThe trainer allows to learn a new set of transformation rules from a corpus. \nIt takes as input a tagged corpus and a set of rule templates. The algorithm \ngenerates positive rules (rules that apply at some location in the corpus) \nfrom the templates and iteratively extends and optimises the rule set.\n\nFirst, a corpus should be loaded. Currently, the format of Brown corpus is supported. Then a lexicon can be created from the corpus. The lexicon is needed for tagging the sentences before the learning algorithm is applied.\n```javascript\nvar natural = require(natural);\nvar text = fs.readFileSync(brownCorpusFile, 'utf8');\nvar corpus = new natural.Corpus(text, 1);\nvar lexicon = corpus.buildLexicon();\n```\nThe next step is to create a set of rule templates from which the learning \nalgorithm can generate transformation rules. Rule templates are defined in \n<code>PredicateMapping.js</code>.\n```javascript\nvar natural require('natural');\nvar templateNames = [\n  \"NEXT-TAG\",\n  \"NEXT-WORD-IS-CAP\",\n  \"PREV-1-OR-2-OR-3-TAG\",\n  \"...\",\n];\nvar templates = templateNames.map(function(name) {\n  return new natural.RuleTemplate(name);\n});\n```\nUsing lexicon and rule templates we can now start the trainer as follows.\n```javascript\nvar natural require('natural');\nvar Tester = require('natural.BrillPOSTrainer');\nvar trainer = new Trainer(/* optional threshold */);\nvar ruleSet = trainer.train(corpus, templates, lexicon);\n```\nA threshold value can be passed to constructor. Transformation rules with \na score below the threshold are removed after training.\nThe train method returns a set of transformation rules that can be used to \ncreate a POS tagger as usual. Also you can output the rule set in the right \nformat for later usage.\n```javascript\nconsole.log(ruleSet.prettyPrint());\n```\n\n### Testing\nNow we can apply the lexicon and rule set to a test set. \n```javascript\nvar tester = new natural.BrillPOSTester();\nvar tagger = new natural.BrillPOSTagger(lexicon, ruleSet);\nvar scores = tester.test(corpora[1], tagger);\n```\nThe test method returns an array of two percentages: first percentage is the ratio of right tags after tagging with the lexicon; second percentage is the ratio of right tags after applying the transformation rules.\n```javascript\nconsole.log(\"Test score lexicon \" + scores[0] + \"%\");\nconsole.log(\"Test score after applying rules \" + scores[1] + \"%\");\n```\n\n### Acknowledgements and References\n* Part of speech tagger by Percy Wegmann, https://code.google.com/p/jspos/\n* Node.js version of jspos: https://github.com/neopunisher/pos-js\n* A simple rule-based part of speech tagger, Eric Brill, Published in: Proceeding ANLC '92 Proceedings of the third conference on Applied natural language processing, Pages 152-155. http://dl.acm.org/citation.cfm?id=974526\n* Exploring the Statistical Derivation of Transformational Rule Sequences for Part-of-Speech Tagging, Lance A. Ramshaw and Mitchell P. Marcus. http://acl-arc.comp.nus.edu.sg/archives/acl-arc-090501d4/data/pdf/anthology-PDF/W/W94/W94-0111.pdf\n* Brown Corpus, https://en.wikipedia.org/wiki/Brown_Corpus\n\n## Development\n\nWhen developing, please:\n\n+ Write unit tests\n+ Make sure your unit tests pass\n\nThe current configuration of the unit tests requires the following environment variable to be set:\n\n    export NODE_PATH=.\n\n\n## License\n\nCopyright (c) 2011, 2012 Chris Umbel, Rob Ellis, Russell Mull\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\nWordNet License\n---------------\n\nThis license is available as the file LICENSE in any downloaded version of WordNet.\nWordNet 3.0 license: (Download)\n\nWordNet Release 3.0 This software and database is being provided to you, the LICENSEE, by Princeton University under the following license. By obtaining, using and/or copying this software and database, you agree that you have read, understood, and will comply with these terms and conditions.: Permission to use, copy, modify and distribute this software and database and its documentation for any purpose and without fee or royalty is hereby granted, provided that you agree to comply with the following copyright notice and statements, including the disclaimer, and that the same appear on ALL copies of the software, database and documentation, including modifications that you make for internal use or for distribution. WordNet 3.0 Copyright 2006 by Princeton University. All rights reserved. THIS SOFTWARE AND DATABASE IS PROVIDED \"AS IS\" AND PRINCETON UNIVERSITY MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, PRINCETON UNIVERSITY MAKES NO REPRESENTATIONS OR WARRANTIES OF MERCHANT- ABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE LICENSED SOFTWARE, DATABASE OR DOCUMENTATION WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS. The name of Princeton University or Princeton may not be used in advertising or publicity pertaining to distribution of the software and/or database. Title to copyright in this software, database and any associated documentation shall at all times remain with Princeton University and LICENSEE agrees to preserve same.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/NaturalNode/natural.git"
  },
  "scripts": {
    "test": "NODE_PATH=. node_modules/jasmine-node/bin/jasmine-node spec/"
  },
  "version": "0.5.4"
}
